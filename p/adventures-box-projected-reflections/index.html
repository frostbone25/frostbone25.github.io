<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Exploring and messing about with box projected cubemap reflections."><title>Box Projected Cubemap Reflections</title><link rel=canonical href=https://frostbone25.github.io/p/adventures-box-projected-reflections/><link rel=stylesheet href=/scss/style.min.833d6eed45de56f48306bf57268d5b8cdfc8a60e8e7bdc99810464fcd033f7c6.css><meta property='og:title' content="Box Projected Cubemap Reflections"><meta property='og:description' content="Exploring and messing about with box projected cubemap reflections."><meta property='og:url' content='https://frostbone25.github.io/p/adventures-box-projected-reflections/'><meta property='og:site_name' content='David Matos'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Unity3D'><meta property='article:tag' content='Cubemaps'><meta property='article:tag' content='Reflections'><meta property='article:tag' content='Specular'><meta property='article:published_time' content='2026-01-06T00:00:00+00:00'><meta property='article:modified_time' content='2026-01-06T00:00:00+00:00'><meta property='og:image' content='https://frostbone25.github.io/p/adventures-box-projected-reflections/5-box-projectedGodotA.png'><meta name=twitter:title content="Box Projected Cubemap Reflections"><meta name=twitter:description content="Exploring and messing about with box projected cubemap reflections."><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://frostbone25.github.io/p/adventures-box-projected-reflections/5-box-projectedGodotA.png'><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_4dd1a7adeca92f6.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>David Matos</a></h1><h2 class=site-description>XR Software Engineer</h2></div></header><ol class=menu-social><li><a href=https://github.com/frostbone25 target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/contact-/-links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Contact / Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><ol><li><ol><li><a href=#table-of-contents>Table of Contents</a></li></ol></li></ol></li></ol><ol><li><a href=#contact-hardening>Contact Hardening</a><ol><li><ol><li><a href=#contact-hardening-none>Contact Hardening: None</a></li><li><a href=#code>Code</a></li><li><a href=#contact-hardening-approximated>Contact Hardening: Approximated</a></li><li><a href=#code-1>Code</a></li><li><a href=#contact-hardening-hdrp-approximation--frostbite-engine>Contact Hardening: HDRP Approximation / Frostbite Engine</a></li><li><a href=#contact-hardening-godot-approximation>Contact Hardening: Godot Approximation</a></li><li><a href=#contact-hardening-raytraced>Contact Hardening: Raytraced</a></li></ol></li><li><a href=#contact-hardening-comparisons-non-normal-mapped-material>Contact Hardening Comparisons (Non-Normal Mapped Material)</a></li><li><a href=#contact-hardening-comparisons-normal-mapped-material>Contact Hardening Comparisons (Normal Mapped Material)</a><ol><li><a href=#contact-hardening-raytracing-options>Contact Hardening: Raytracing Options</a></li><li><a href=#static-noise-non-deterministic-sampling>Static Noise <em>(Non-Deterministic Sampling)</em></a></li><li><a href=#animated-noise-non-deterministic-sampling>Animated Noise <em>(Non-Deterministic Sampling)</em></a></li><li><a href=#deterministic-sampling>Deterministic Sampling</a></li></ol></li></ol></li><li><a href=#beveled-box-projection>Beveled Box Projection</a><ol><li><ol><li><a href=#beveled-box-projection-off>Beveled Box Projection: Off</a></li><li><a href=#beveled-box-projection-on>Beveled Box Projection: On</a></li></ol></li></ol></li><li><a href=#box-based-specular-occlusion>Box Based Specular Occlusion</a><ol><li><ol><li><a href=#box-occlusion-off>Box Occlusion: Off</a></li><li><a href=#box-occlusion-on>Box Occlusion: On</a></li></ol></li><li><a href=#todoideas>TODO/Ideas:</a></li><li><a href=#credits--sources>Credits / Sources</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/adventures-box-projected-reflections/><img src=/p/adventures-box-projected-reflections/5-box-projectedGodotA_hu_7680eafa59075065.png srcset="/p/adventures-box-projected-reflections/5-box-projectedGodotA_hu_7680eafa59075065.png 800w, /p/adventures-box-projected-reflections/5-box-projectedGodotA_hu_84e21ee6ff799211.png 1600w" width=800 height=474 loading=lazy alt="Featured image of post Box Projected Cubemap Reflections"></a></div><div class=article-details><header class=article-category><a href=/categories/graphics/>Graphics</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/adventures-box-projected-reflections/>Box Projected Cubemap Reflections</a></h2><h3 class=article-subtitle>Exploring and messing about with box projected cubemap reflections.</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2026-01-06T00:00:00Z>Jan 06, 2026</time></div></footer></div></header><section class=article-content><p><em>By: David Matos</em></p><p>My adventures into improving Box Projected Specular Reflections!</p><p><a class=link href=https://github.com/frostbone25/Unity-Improved-Box-Projected-Reflections/tree/main target=_blank rel=noopener>You can find the Github Repository Here!</a></p><p><em>NOTE: In-case it isn&rsquo;t obvious, most of the examples/images shown here are of a pure metallic/reflective material to show the effects more clearly. Specifically the material is configured to be fully metallic, with smoothness/perceptualRoughness at 0.5 or 50%.</em></p><p float=left><img src=2-box-projectedA.png width=49%>
<img src=5-box-projectedGodotA.png width=49%></p><h4 id=table-of-contents><a href=#table-of-contents class=header-anchor></a>Table of Contents</h4><ul><li><a class=link href=#preface>Preface</a></li><li><a class=link href=#contact-hardening>Contact Hardening</a><ul><li><a class=link href=#contact-hardening-none>Contact Hardening: None</a></li><li><a class=link href=#contact-hardening-approximated>Contact Hardening: Approximated</a></li><li><a class=link href=#contact-hardening-hdrp-approximation--frostbite-engine>Contact Hardening: HDRP Approximation / Frostbite Engine</a></li><li><a class=link href=#contact-hardening-godot-approximation>Contact Hardening: Godot Approximation</a></li><li><a class=link href=#contact-hardening-raytraced>Contact Hardening: Raytraced</a></li><li><a class=link href=#contact-hardening-raytracing-options>Contact Hardening: Raytracing Options</a><ul><li><a class=link href=#static-noise-non-deterministic-sampling>Static Noise <em>(Non-Deterministic Sampling)</em></a></li><li><a class=link href=#animated-noise-non-deterministic-sampling>Animated Noise <em>(Non-Deterministic Sampling)</em></a></li><li><a class=link href=#deterministic-sampling>Deterministic Sampling</a></li></ul></li></ul></li><li><a class=link href=#beveled-box-projection>Beveled Box Projection</a></li><li><a class=link href=#box-based-specular-occlusion>Box Based Specular Occlusion</a></li><li><a class=link href=#credits--sources>Credits / Sources</a></li></ul><h1 id=preface><a href=#preface class=header-anchor></a>Preface</h1><p>Cubemap Reflections are a very common and simple way to provide reflection/specular data to a set of objects in a scene <em>(or a specific area within a scene)</em>.</p><p><img src=/p/adventures-box-projected-reflections/reflection-probe-gizmo.png width=1117 height=662 srcset="/p/adventures-box-projected-reflections/reflection-probe-gizmo_hu_21a95240f3a549.png 480w, /p/adventures-box-projected-reflections/reflection-probe-gizmo_hu_23c4af0c933163c1.png 1024w" loading=lazy alt=reflection-probe-gizmo class=gallery-image data-flex-grow=168 data-flex-basis=404px></p><p>A probe is placed at a specific point, and at runtime <em>(or during baking)</em> a camera captures the scene at 6 different orientations <em>(90 degrees, within a square)</em>.</p><p><img src=/p/adventures-box-projected-reflections/learn-open-gl-cubemap-graphic.png width=700 height=525 srcset="/p/adventures-box-projected-reflections/learn-open-gl-cubemap-graphic_hu_709251ad241ab52e.png 480w, /p/adventures-box-projected-reflections/learn-open-gl-cubemap-graphic_hu_a8e539e5a91ef802.png 1024w" loading=lazy alt=learn-open-gl-cubemap-graphic class=gallery-image data-flex-grow=133 data-flex-basis=320px></p><p><em>Graphic from <a class=link href=https://learnopengl.com/Advanced-OpenGL/Cubemaps target=_blank rel=noopener>LearnOpenGL</a></em></p><p>Each of the faces of this &ldquo;cube&rdquo; are combined into a cubemap texture asset. Then this texture asset goes through an additional process step called &ldquo;specular convolution&rdquo; which effectively generates a convolved or &ldquo;blurred&rdquo; version of the cubemap that coresponds with &ldquo;rougher&rdquo; reflections that get stored in the mips of the texture. <em>(This is important so when the cubemap reflection gets sampled, objects with rougher surfaces can have blurrier reflections)</em></p><div class=table-wrapper><table><thead><tr><th>Mip 0</th><th>Mip 1</th><th>Mip 2</th><th>Mip 3</th><th>Mip 4</th><th>Mip 5</th></tr></thead><tbody><tr><td><img src=/p/adventures-box-projected-reflections/mip0.png width=1117 height=662 srcset="/p/adventures-box-projected-reflections/mip0_hu_ad20ddef8f3ff653.png 480w, /p/adventures-box-projected-reflections/mip0_hu_4660dbd104a47d65.png 1024w" loading=lazy alt=mip0 class=gallery-image data-flex-grow=168 data-flex-basis=404px></td><td><img src=/p/adventures-box-projected-reflections/mip1.png width=1117 height=662 srcset="/p/adventures-box-projected-reflections/mip1_hu_abc6a73e064394e1.png 480w, /p/adventures-box-projected-reflections/mip1_hu_8b55cb38d7654014.png 1024w" loading=lazy alt=mip1 class=gallery-image data-flex-grow=168 data-flex-basis=404px></td><td><img src=/p/adventures-box-projected-reflections/mip2.png width=1117 height=662 srcset="/p/adventures-box-projected-reflections/mip2_hu_55e9319764df5373.png 480w, /p/adventures-box-projected-reflections/mip2_hu_f615e02f13e1cfc4.png 1024w" loading=lazy alt=mip2 class=gallery-image data-flex-grow=168 data-flex-basis=404px></td><td><img src=/p/adventures-box-projected-reflections/mip3.png width=1117 height=662 srcset="/p/adventures-box-projected-reflections/mip3_hu_4403839c5604aab7.png 480w, /p/adventures-box-projected-reflections/mip3_hu_70504502bb844b2.png 1024w" loading=lazy alt=mip3 class=gallery-image data-flex-grow=168 data-flex-basis=404px></td><td><img src=/p/adventures-box-projected-reflections/mip4.png width=1117 height=662 srcset="/p/adventures-box-projected-reflections/mip4_hu_f4522cc6e37bd5d5.png 480w, /p/adventures-box-projected-reflections/mip4_hu_3000845969f20e7e.png 1024w" loading=lazy alt=mip4 class=gallery-image data-flex-grow=168 data-flex-basis=404px></td><td><img src=/p/adventures-box-projected-reflections/mip5.png width=1117 height=662 srcset="/p/adventures-box-projected-reflections/mip5_hu_c92f0abc7a551537.png 480w, /p/adventures-box-projected-reflections/mip5_hu_5fd68fa0a5912391.png 1024w" loading=lazy alt=mip5 class=gallery-image data-flex-grow=168 data-flex-basis=404px></td></tr></tbody></table></div><p>This then can be fed to objects within an Axis-Aligned Bounding Box (AABB) Volume inside a scene to sample environment reflections.</p><p float=left><img src=1-classic-cubemapA.png width=49%>
<img src=1-classic-cubemapB.png width=49%></p><p><em>Left: No Normal Mapping | Right: Normal Mapped</em></p><p>However, as Physically Based Rendering and Shading became standard, reflections are a huge part of how an object is shaded now. Sampling this cubemap for environment reflections as-is is not convincing enough in most cases.</p><p>These reflection probes are usually authored to be placed using an Axis-Aligned Bounding Box Volume (AABB), to tell objects within the volume to use a specific reflection cubemap.</p><p><img src=/p/adventures-box-projected-reflections/2-box-projectedC.png width=1117 height=662 srcset="/p/adventures-box-projected-reflections/2-box-projectedC_hu_63a676c11327de16.png 480w, /p/adventures-box-projected-reflections/2-box-projectedC_hu_1b5b51847d5e4cb4.png 1024w" loading=lazy alt=2-box-projectedC class=gallery-image data-flex-grow=168 data-flex-basis=404px></p><p>Now fortunately the industry devised a clever way to improve upon the quality of these reflections by projecting the reflection vector onto a box-shape. The box shape in question is the very same AABB volume used to define the reflection volume in the first place, this is parallax-corrected cubemaps.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-HLSL data-lang=HLSL><span class=line><span class=cl><span class=c1>//compute reflection vector</span>
</span></span><span class=line><span class=cl><span class=kt>float3</span> <span class=n>vector_reflectionDirection</span> <span class=o>=</span> <span class=nb>reflect</span><span class=p>(</span><span class=o>-</span><span class=n>vector_viewDirection</span><span class=p>,</span> <span class=n>vector_normalDirection</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//project reflection vector onto box</span>
</span></span><span class=line><span class=cl><span class=n>vector_reflectionDirection</span> <span class=o>=</span> <span class=n>BoxProjectedCubemapDirection</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>vector_reflectionDirection</span><span class=p>,</span>     <span class=c1>//the original reflection vector to project</span>
</span></span><span class=line><span class=cl>    <span class=n>vector_worldPosition</span><span class=p>,</span>           <span class=c1>//world position</span>
</span></span><span class=line><span class=cl>    <span class=n>vector_reflectionProbePosition</span><span class=p>,</span> <span class=c1>//the reflection probe position</span>
</span></span><span class=line><span class=cl>    <span class=n>vector_reflectionProbeBoxMin</span><span class=p>,</span>   <span class=c1>//reflection probe AABB min</span>
</span></span><span class=line><span class=cl>    <span class=n>vector_reflectionProbeBoxMax</span><span class=p>);</span>  <span class=c1>//reflection probe AABB max</span>
</span></span></code></pre></td></tr></table></div></div><p float=left><img src=2-box-projectedA.png width=49%>
<img src=2-box-projectedB.png width=49%></p><p><em>Left: Box Projected + No Normal Mapping | Right: Box Projected + Normal Mapped</em></p><p>However, there is an issue with this approach&mldr;</p><p>When sampling the reflection, we choose the mip level based on surface roughness. Meaning that the reflection has a consistent mip level <em>(or sharpness)</em> wherever it is being sampled from within the volume.</p><p>This assumption works fine for non-parallax corrected cubemaps <em>(because the volume is essentially infinitely large)</em>, but factoring in parallax correction where we have a finite-sized volume this assumption starts to fall apart.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-HLSL data-lang=HLSL><span class=line><span class=cl><span class=kt>float</span> <span class=n>perceptualRoughness</span> <span class=o>=</span> <span class=mf>1.0</span> <span class=o>-</span> <span class=n>_Smoothness</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>mip</span> <span class=o>=</span> <span class=n>perceptualRoughness</span> <span class=o>*</span> <span class=n>MAX_REFLECTION_PROBE_MIP_LEVEL</span><span class=p>;</span> <span class=c1>//&lt;--- this is not enough anymore!</span>
</span></span></code></pre></td></tr></table></div></div><p><img src=/p/adventures-box-projected-reflections/real-world-contact-hardening.jpg width=1280 height=1280 srcset="/p/adventures-box-projected-reflections/real-world-contact-hardening_hu_f932e22052a4c7af.jpg 480w, /p/adventures-box-projected-reflections/real-world-contact-hardening_hu_fbd570d38f92a4d9.jpg 1024w" loading=lazy alt=real-world-contact-hardening class=gallery-image data-flex-grow=100 data-flex-basis=240px></p><p>When we look at the real world, we notice that when reflections are closer to the source they remain relatively sharp. The further it goes the blurrier/rougher it gets. This phenomena is not accounted for when sampling our own reflection probes.</p><p>So when sampling the reflection cubemap, the mip level should vary not just based on surface roughness, but also depending on how close we are to the source.</p><h2 id=contact-hardening><a href=#contact-hardening class=header-anchor></a>Contact Hardening</h2><h4 id=contact-hardening-none><a href=#contact-hardening-none class=header-anchor></a>Contact Hardening: None</h4><p><img src=/p/adventures-box-projected-reflections/2-box-projectedA.png width=1117 height=662 srcset="/p/adventures-box-projected-reflections/2-box-projectedA_hu_a3053128fa8fa403.png 480w, /p/adventures-box-projected-reflections/2-box-projectedA_hu_4a02811062732156.png 1024w" loading=lazy alt=2-box-projectedA class=gallery-image data-flex-grow=168 data-flex-basis=404px></p><h4 id=code><a href=#code class=header-anchor></a>Code</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-HLSL data-lang=HLSL><span class=line><span class=cl><span class=c1>//Unity&#39;s Default Box Projection function</span>
</span></span><span class=line><span class=cl><span class=k>inline</span> <span class=kt>float3</span> <span class=n>UnityBoxProjectedCubemapDirectionDefault</span><span class=p>(</span><span class=kt>float3</span> <span class=n>worldRefl</span><span class=p>,</span> <span class=kt>float3</span> <span class=n>worldPos</span><span class=p>,</span> <span class=kt>float4</span> <span class=n>cubemapCenter</span><span class=p>,</span> <span class=kt>float4</span> <span class=n>boxMin</span><span class=p>,</span> <span class=kt>float4</span> <span class=n>boxMax</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>nrdir</span> <span class=o>=</span> <span class=nb>normalize</span><span class=p>(</span><span class=n>worldRefl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>rbmax</span> <span class=o>=</span> <span class=p>(</span><span class=n>boxMax</span><span class=p>.</span><span class=n>xyz</span> <span class=o>-</span> <span class=n>worldPos</span><span class=p>)</span> <span class=o>/</span> <span class=n>nrdir</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>rbmin</span> <span class=o>=</span> <span class=p>(</span><span class=n>boxMin</span><span class=p>.</span><span class=n>xyz</span> <span class=o>-</span> <span class=n>worldPos</span><span class=p>)</span> <span class=o>/</span> <span class=n>nrdir</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>rbminmax</span> <span class=o>=</span> <span class=p>(</span><span class=n>nrdir</span> <span class=o>&gt;</span> <span class=mf>0.0f</span><span class=p>)</span> <span class=o>?</span> <span class=n>rbmax</span> <span class=o>:</span> <span class=n>rbmin</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>dist</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=nb>min</span><span class=p>(</span><span class=n>rbminmax</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>rbminmax</span><span class=p>.</span><span class=n>y</span><span class=p>),</span> <span class=n>rbminmax</span><span class=p>.</span><span class=n>z</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>worldPos</span> <span class=o>-=</span> <span class=n>cubemapCenter</span><span class=p>.</span><span class=n>xyz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>worldRefl</span> <span class=o>=</span> <span class=n>worldPos</span> <span class=o>+</span> <span class=n>nrdir</span> <span class=o>*</span> <span class=n>dist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>worldRefl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-HLSL data-lang=HLSL><span class=line><span class=cl><span class=c1>//in object fragment shader...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//compute reflection vector</span>
</span></span><span class=line><span class=cl><span class=kt>float3</span> <span class=n>vector_reflectionDirection</span> <span class=o>=</span> <span class=nb>reflect</span><span class=p>(</span><span class=o>-</span><span class=n>vector_viewDirection</span><span class=p>,</span> <span class=n>vector_normalDirection</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//if box projection is enabled, modify our vector to project reflections onto a world space box (defined by the reflection probe)</span>
</span></span><span class=line><span class=cl><span class=n>vector_reflectionDirection</span> <span class=o>=</span> <span class=n>UnityBoxProjectedCubemapDirectionDefault</span><span class=p>(</span><span class=n>vector_reflectionDirection</span><span class=p>,</span> <span class=n>vector_worldPosition</span><span class=p>,</span> <span class=n>unity_SpecCube0_ProbePosition</span><span class=p>,</span> <span class=n>unity_SpecCube0_BoxMin</span><span class=p>,</span> <span class=n>unity_SpecCube0_BoxMax</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//remap our smoothness parameter to PBR roughness</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>perceptualRoughness</span> <span class=o>=</span> <span class=mf>1.0</span> <span class=o>-</span> <span class=n>_Smoothness</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>roughness</span> <span class=o>=</span> <span class=n>perceptualRoughness</span> <span class=o>*</span> <span class=n>perceptualRoughness</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//compute the cubemap mip level based on perceptual roughness</span>
</span></span><span class=line><span class=cl><span class=c1>//NOTE: in unity this is perceptualRoughness * UNITY_SPECCUBE_LOD_STEPS</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>mip</span> <span class=o>=</span> <span class=n>UnityPerceptualRoughnessToMipmapLevel</span><span class=p>(</span><span class=n>perceptualRoughness</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//sample the environment reflection</span>
</span></span><span class=line><span class=cl><span class=n>enviormentReflection</span> <span class=o>=</span> <span class=n>UNITY_SAMPLE_TEXCUBE_LOD</span><span class=p>(</span><span class=n>unity_SpecCube0</span><span class=p>,</span> <span class=n>vector_reflectionDirection</span><span class=p>.</span><span class=n>xyz</span><span class=p>,</span> <span class=n>mip</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>enviormentReflection</span><span class=p>.</span><span class=n>rgb</span> <span class=o>=</span> <span class=n>DecodeHDR</span><span class=p>(</span><span class=n>enviormentReflection</span><span class=p>,</span> <span class=n>unity_SpecCube0_HDR</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>This is the usual way to sample box-projected cubemap reflections. The issue as I described though is that the roughness of the reflection is consistent across the entire volume regardless of camera position, and object position. This is not the case when you compare it to the the real world, or a proper raytraced/ground truth result.</p><p>With that there are a few implementations I explored that attempt to alleviate that problem and make them more true to life and higher fidelity.</p><h4 id=contact-hardening-approximated><a href=#contact-hardening-approximated class=header-anchor></a>Contact Hardening: Approximated</h4><p><img src=/p/adventures-box-projected-reflections/3-box-projectedApproxA.png width=1117 height=662 srcset="/p/adventures-box-projected-reflections/3-box-projectedApproxA_hu_ff021dc54bcc282e.png 480w, /p/adventures-box-projected-reflections/3-box-projectedApproxA_hu_b1ccfc1aaee68eec.png 1024w" loading=lazy alt=3-box-projectedApproxA class=gallery-image data-flex-grow=168 data-flex-basis=404px></p><h4 id=code-1><a href=#code-1 class=header-anchor></a>Code</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-HLSL data-lang=HLSL><span class=line><span class=cl><span class=c1>//Unity&#39;s Default Box Projection function, tweaked to output hit distance</span>
</span></span><span class=line><span class=cl><span class=k>inline</span> <span class=kt>float3</span> <span class=n>UnityBoxProjectedCubemapDirectionDefault</span><span class=p>(</span><span class=kt>float3</span> <span class=n>worldRefl</span><span class=p>,</span> <span class=kt>float3</span> <span class=n>worldPos</span><span class=p>,</span> <span class=kt>float4</span> <span class=n>cubemapCenter</span><span class=p>,</span> <span class=kt>float4</span> <span class=n>boxMin</span><span class=p>,</span> <span class=kt>float4</span> <span class=n>boxMax</span><span class=p>,</span> <span class=k>out</span> <span class=kt>float</span> <span class=n>distanceToHitPoint</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>nrdir</span> <span class=o>=</span> <span class=nb>normalize</span><span class=p>(</span><span class=n>worldRefl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>rbmax</span> <span class=o>=</span> <span class=p>(</span><span class=n>boxMax</span><span class=p>.</span><span class=n>xyz</span> <span class=o>-</span> <span class=n>worldPos</span><span class=p>)</span> <span class=o>/</span> <span class=n>nrdir</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>rbmin</span> <span class=o>=</span> <span class=p>(</span><span class=n>boxMin</span><span class=p>.</span><span class=n>xyz</span> <span class=o>-</span> <span class=n>worldPos</span><span class=p>)</span> <span class=o>/</span> <span class=n>nrdir</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>rbminmax</span> <span class=o>=</span> <span class=p>(</span><span class=n>nrdir</span> <span class=o>&gt;</span> <span class=mf>0.0f</span><span class=p>)</span> <span class=o>?</span> <span class=n>rbmax</span> <span class=o>:</span> <span class=n>rbmin</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>distanceToHitPoint</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=nb>min</span><span class=p>(</span><span class=n>rbminmax</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>rbminmax</span><span class=p>.</span><span class=n>y</span><span class=p>),</span> <span class=n>rbminmax</span><span class=p>.</span><span class=n>z</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>worldPos</span> <span class=o>-=</span> <span class=n>cubemapCenter</span><span class=p>.</span><span class=n>xyz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>worldRefl</span> <span class=o>=</span> <span class=n>worldPos</span> <span class=o>+</span> <span class=n>nrdir</span> <span class=o>*</span> <span class=n>distanceToHitPoint</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>worldRefl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-HLSL data-lang=HLSL><span class=line><span class=cl><span class=c1>//in object fragment shader...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//compute reflection vector</span>
</span></span><span class=line><span class=cl><span class=kt>float3</span> <span class=n>vector_reflectionDirection</span> <span class=o>=</span> <span class=nb>reflect</span><span class=p>(</span><span class=o>-</span><span class=n>vector_viewDirection</span><span class=p>,</span> <span class=n>vector_normalDirection</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//remap our smoothness parameter to PBR roughness</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>perceptualRoughness</span> <span class=o>=</span> <span class=mf>1.0</span> <span class=o>-</span> <span class=n>_Smoothness</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>roughness</span> <span class=o>=</span> <span class=n>perceptualRoughness</span> <span class=o>*</span> <span class=n>perceptualRoughness</span><span class=p>;</span> <span class=c1>//offical roughness term for pbr shading</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//compute the cubemap mip level based on perceptual roughness</span>
</span></span><span class=line><span class=cl><span class=c1>//NOTE: this is basically perceptualRoughness * UNITY_SPECCUBE_LOD_STEPS</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>mipOriginal</span> <span class=o>=</span> <span class=n>UnityPerceptualRoughnessToMipmapLevel</span><span class=p>(</span><span class=n>perceptualRoughness</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//this will store the &#34;intersectionDistance&#34; result from the box projection</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>intersectionDistance</span> <span class=o>=</span> <span class=mo>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//if box projection is enabled, modify our vector to project reflections onto a world space box (defined by the reflection probe)</span>
</span></span><span class=line><span class=cl><span class=n>vector_reflectionDirection</span> <span class=o>=</span> <span class=n>UnityBoxProjectedCubemapDirectionDefault</span><span class=p>(</span><span class=n>vector_reflectionDirection</span><span class=p>,</span> <span class=n>vector_worldPosition</span><span class=p>,</span> <span class=n>unity_SpecCube0_ProbePosition</span><span class=p>,</span> <span class=n>unity_SpecCube0_BoxMin</span><span class=p>,</span> <span class=n>unity_SpecCube0_BoxMax</span><span class=p>,</span> <span class=n>intersectionDistance</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//added a clamp to the mip offset, helps to make sure that when a fragment is far away the mip level doesn&#39;t climb to a high value and look wierd</span>
</span></span><span class=line><span class=cl><span class=c1>//this tends to look much better when clamped</span>
</span></span><span class=line><span class=cl><span class=n>intersectionDistance</span> <span class=o>=</span> <span class=nb>clamp</span><span class=p>(</span><span class=n>intersectionDistance</span><span class=p>,</span> <span class=mf>0.0f</span><span class=p>,</span> <span class=n>UNITY_SPECCUBE_LOD_STEPS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//compute new mip level based on the intersectionDistance value (this is mostly arbitrary)</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>mip</span> <span class=o>=</span> <span class=nb>lerp</span><span class=p>(</span><span class=mf>0.0f</span><span class=p>,</span> <span class=n>mipOriginal</span><span class=p>,</span> <span class=n>intersectionDistance</span> <span class=o>/</span> <span class=n>UNITY_SPECCUBE_LOD_STEPS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//sample the provided reflection probe at the given mip level</span>
</span></span><span class=line><span class=cl><span class=n>enviormentReflection</span> <span class=o>=</span> <span class=n>UNITY_SAMPLE_TEXCUBE_LOD</span><span class=p>(</span><span class=n>unity_SpecCube0</span><span class=p>,</span> <span class=n>vector_reflectionDirection</span><span class=p>.</span><span class=n>xyz</span><span class=p>,</span> <span class=n>mip</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>enviormentReflection</span><span class=p>.</span><span class=n>rgb</span> <span class=o>=</span> <span class=n>DecodeHDR</span><span class=p>(</span><span class=n>enviormentReflection</span><span class=p>,</span> <span class=n>unity_SpecCube0_HDR</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>This is achieved by modifying the existing box projection method to output a hit distance from the bounds of the box, to where the current fragment/pixel is.</p><p>This hit distance is then used to offset the mip level when sampling the cubemap to be sharper when closer to the bounds of the probe, and rougher when farther from the bounds. It&rsquo;s very cheap and fast, though not accurate as it fails to model anisotropic reflections <em>(Isotropic, or specular elongation)</em>.</p><p>Despite that, this alleviates a couple of visual problems we saw before.</p><ol><li>This attempts to solve the problem of reflections being too consistent across the entire volume, making them look closer to a proper raytraced result. <em>(I.e the closer to the actual source of the reflection bounds, the sharper the reflection gets)</em></li><li>In most situations this contact hardening actually contributes to improved specular occlusion. Since the contact hardening reflections reveal the underlying cubemap more, there is less of a glowing appearance in the corners of the bounds. <em>(NOTE: This is assuming your reflection probe is placed and configured well to approximate the geometry of the space/room, if it&rsquo;s not this might also contribute to light leaking)</em></li></ol><p>This is a marginal improvement over the classic method, and it&rsquo;s really cheap!</p><p><strong>NOTE:</strong> <em>The approximation is mostly arbitrarily tweaked by hand with random values until it looks right, or otherwise known as &ldquo;banging random rocks together until we get something decent&rdquo;. In addition, any possible tricks to help with mimicking anisotropic reflections would help here.</em></p><h4 id=contact-hardening-hdrp-approximation--frostbite-engine><a href=#contact-hardening-hdrp-approximation--frostbite-engine class=header-anchor></a>Contact Hardening: HDRP Approximation / Frostbite Engine</h4><p><img src=/p/adventures-box-projected-reflections/4-box-projectedHDRPA.png width=1117 height=662 srcset="/p/adventures-box-projected-reflections/4-box-projectedHDRPA_hu_65b187b16d38035e.png 480w, /p/adventures-box-projected-reflections/4-box-projectedHDRPA_hu_9cc5db9f7be1f457.png 1024w" loading=lazy alt=4-box-projectedHDRPA class=gallery-image data-flex-grow=168 data-flex-basis=404px></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-HLSL data-lang=HLSL><span class=line><span class=cl><span class=c1>//From Moving Frostbite to PBR document</span>
</span></span><span class=line><span class=cl><span class=c1>//This function fakes the roughness based integration of reflection probes by adjusting the roughness value</span>
</span></span><span class=line><span class=cl><span class=c1>//NOTE: Untouched from HDRP</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>ComputeDistanceBaseRoughness</span><span class=p>(</span><span class=kt>float</span> <span class=n>distanceIntersectionToShadedPoint</span><span class=p>,</span> <span class=kt>float</span> <span class=n>distanceIntersectionToProbeCenter</span><span class=p>,</span> <span class=kt>float</span> <span class=n>perceptualRoughness</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>newPerceptualRoughness</span> <span class=o>=</span> <span class=nb>clamp</span><span class=p>(</span><span class=n>distanceIntersectionToShadedPoint</span> <span class=o>/</span> <span class=n>distanceIntersectionToProbeCenter</span> <span class=o>*</span> <span class=n>perceptualRoughness</span><span class=p>,</span> <span class=mo>0</span><span class=p>,</span> <span class=n>perceptualRoughness</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>lerp</span><span class=p>(</span><span class=n>newPerceptualRoughness</span><span class=p>,</span> <span class=n>perceptualRoughness</span><span class=p>,</span> <span class=n>perceptualRoughness</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//This simplified version assume that we care about the result only when we are inside the box</span>
</span></span><span class=line><span class=cl><span class=c1>//NOTE: Untouched from HDRP</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>IntersectRayAABBSimple</span><span class=p>(</span><span class=kt>float3</span> <span class=n>start</span><span class=p>,</span> <span class=kt>float3</span> <span class=n>dir</span><span class=p>,</span> <span class=kt>float3</span> <span class=n>boxMin</span><span class=p>,</span> <span class=kt>float3</span> <span class=n>boxMax</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>invDir</span> <span class=o>=</span> <span class=nb>rcp</span><span class=p>(</span><span class=n>dir</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Find the ray intersection with box plane</span>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>rbmin</span> <span class=o>=</span> <span class=p>(</span><span class=n>boxMin</span> <span class=o>-</span> <span class=n>start</span><span class=p>)</span> <span class=o>*</span> <span class=n>invDir</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>rbmax</span> <span class=o>=</span> <span class=p>(</span><span class=n>boxMax</span> <span class=o>-</span> <span class=n>start</span><span class=p>)</span> <span class=o>*</span> <span class=n>invDir</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>rbminmax</span> <span class=o>=</span> <span class=kt>float3</span><span class=p>((</span><span class=n>dir</span><span class=p>.</span><span class=n>x</span> <span class=o>&gt;</span> <span class=mf>0.0</span><span class=p>)</span> <span class=o>?</span> <span class=n>rbmax</span><span class=p>.</span><span class=n>x</span> <span class=o>:</span> <span class=n>rbmin</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=p>(</span><span class=n>dir</span><span class=p>.</span><span class=n>y</span> <span class=o>&gt;</span> <span class=mf>0.0</span><span class=p>)</span> <span class=o>?</span> <span class=n>rbmax</span><span class=p>.</span><span class=n>y</span> <span class=o>:</span> <span class=n>rbmin</span><span class=p>.</span><span class=n>y</span><span class=p>,</span> <span class=p>(</span><span class=n>dir</span><span class=p>.</span><span class=n>z</span> <span class=o>&gt;</span> <span class=mf>0.0</span><span class=p>)</span> <span class=o>?</span> <span class=n>rbmax</span><span class=p>.</span><span class=n>z</span> <span class=o>:</span> <span class=n>rbmin</span><span class=p>.</span><span class=n>z</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>min</span><span class=p>(</span><span class=nb>min</span><span class=p>(</span><span class=n>rbminmax</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>rbminmax</span><span class=p>.</span><span class=n>y</span><span class=p>),</span> <span class=n>rbminmax</span><span class=p>.</span><span class=n>z</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//return projectionDistance, can be used in ComputeDistanceBaseRoughness formula</span>
</span></span><span class=line><span class=cl><span class=c1>//return in R the unormalized corrected direction which is used to fetch cubemap but also its length represent the distance of the capture point to the intersection</span>
</span></span><span class=line><span class=cl><span class=c1>//Length R can be reuse as a parameter of ComputeDistanceBaseRoughness for distIntersectionToProbeCenter</span>
</span></span><span class=line><span class=cl><span class=c1>//NOTE: Modified to be much simpler, and to work with the Built-In Render Pipeline (BIRP)</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>EvaluateLight_EnvIntersection</span><span class=p>(</span><span class=kt>float3</span> <span class=n>worldSpacePosition</span><span class=p>,</span> <span class=k>inout</span> <span class=kt>float3</span> <span class=n>R</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>projectionDistance</span> <span class=o>=</span> <span class=n>IntersectRayAABBSimple</span><span class=p>(</span><span class=n>worldSpacePosition</span><span class=p>,</span> <span class=n>R</span><span class=p>,</span> <span class=n>unity_SpecCube0_BoxMin</span><span class=p>.</span><span class=n>xyz</span><span class=p>,</span> <span class=n>unity_SpecCube0_BoxMax</span><span class=p>.</span><span class=n>xyz</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>R</span> <span class=o>=</span> <span class=p>(</span><span class=n>worldSpacePosition</span> <span class=o>+</span> <span class=n>projectionDistance</span> <span class=o>*</span> <span class=n>R</span><span class=p>)</span> <span class=o>-</span> <span class=n>unity_SpecCube0_ProbePosition</span><span class=p>.</span><span class=n>xyz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>projectionDistance</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-HLSL data-lang=HLSL><span class=line><span class=cl><span class=c1>//in object fragment shader...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//compute reflection vector</span>
</span></span><span class=line><span class=cl><span class=kt>float3</span> <span class=n>vector_reflectionDirection</span> <span class=o>=</span> <span class=nb>reflect</span><span class=p>(</span><span class=o>-</span><span class=n>vector_viewDirection</span><span class=p>,</span> <span class=n>vector_normalDirection</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>perceptualRoughness</span> <span class=o>=</span> <span class=mf>1.0</span> <span class=o>-</span> <span class=n>_Smoothness</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//use HDRP method to compute the intersection distance (and also box project vector_reflectionDirection)</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>projectionDistance</span> <span class=o>=</span> <span class=n>EvaluateLight_EnvIntersection</span><span class=p>(</span><span class=n>vector_worldPosition</span><span class=p>,</span> <span class=n>vector_reflectionDirection</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//use HDRP formula to calculate roughness based on distance</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>distanceBasedRoughness</span> <span class=o>=</span> <span class=n>ComputeDistanceBaseRoughness</span><span class=p>(</span><span class=n>projectionDistance</span><span class=p>,</span> <span class=nb>length</span><span class=p>(</span><span class=n>vector_reflectionDirection</span><span class=p>),</span> <span class=n>perceptualRoughness</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//the output of distanceBasedRoughness is the new perceptual roughness</span>
</span></span><span class=line><span class=cl><span class=n>perceptualRoughness</span> <span class=o>=</span> <span class=n>distanceBasedRoughness</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>roughness</span> <span class=o>=</span> <span class=n>perceptualRoughness</span> <span class=o>*</span> <span class=n>perceptualRoughness</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//compute the cubemap mip level based on perceptual roughness</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>mip</span> <span class=o>=</span> <span class=n>UnityPerceptualRoughnessToMipmapLevel</span><span class=p>(</span><span class=n>distanceBasedRoughness</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//sample the provided reflection probe at the given mip level</span>
</span></span><span class=line><span class=cl><span class=n>enviormentReflection</span> <span class=o>=</span> <span class=n>UNITY_SAMPLE_TEXCUBE_LOD</span><span class=p>(</span><span class=n>unity_SpecCube0</span><span class=p>,</span> <span class=n>vector_reflectionDirection</span><span class=p>.</span><span class=n>xyz</span><span class=p>,</span> <span class=n>mip</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>enviormentReflection</span><span class=p>.</span><span class=n>rgb</span> <span class=o>=</span> <span class=n>DecodeHDR</span><span class=p>(</span><span class=n>enviormentReflection</span><span class=p>,</span> <span class=n>unity_SpecCube0_HDR</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>This I found about recently, where <a class=link href=https://docs.unity.cn/Packages/com.unity.render-pipelines.high-definition@13.1/manual/whats-new-10.html target=_blank rel=noopener>Unity HDRP</a> had a very similar implementation to the original approximation I stumbled upon. <em>(The implmentation also stems from improvements made to the Frostbite engine)</em></p><p>The difference being that the approximation used here is less obvious/extreme than the other original approximation I had, and it tries to stay somewhat physically plausible.</p><p>Comparing it to ground truth it is closer in some cases than the other, for a very similar cost. A big improvement over the classic method, and it&rsquo;s really cheap!</p><h4 id=contact-hardening-godot-approximation><a href=#contact-hardening-godot-approximation class=header-anchor></a>Contact Hardening: Godot Approximation</h4><p><img src=/p/adventures-box-projected-reflections/5-box-projectedGodotA.png width=1117 height=662 srcset="/p/adventures-box-projected-reflections/5-box-projectedGodotA_hu_b3d6edd022587737.png 480w, /p/adventures-box-projected-reflections/5-box-projectedGodotA_hu_83d7fb67a470795.png 1024w" loading=lazy alt=5-box-projectedGodotA class=gallery-image data-flex-grow=168 data-flex-basis=404px></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-HLSL data-lang=HLSL><span class=line><span class=cl><span class=c1>//Unity&#39;s Default Box Projection function, tweaked to output hit distance</span>
</span></span><span class=line><span class=cl><span class=k>inline</span> <span class=kt>float3</span> <span class=n>UnityBoxProjectedCubemapDirectionDefault</span><span class=p>(</span><span class=kt>float3</span> <span class=n>worldRefl</span><span class=p>,</span> <span class=kt>float3</span> <span class=n>worldPos</span><span class=p>,</span> <span class=kt>float4</span> <span class=n>cubemapCenter</span><span class=p>,</span> <span class=kt>float4</span> <span class=n>boxMin</span><span class=p>,</span> <span class=kt>float4</span> <span class=n>boxMax</span><span class=p>,</span> <span class=k>out</span> <span class=kt>float</span> <span class=n>distanceToHitPoint</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>nrdir</span> <span class=o>=</span> <span class=nb>normalize</span><span class=p>(</span><span class=n>worldRefl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>rbmax</span> <span class=o>=</span> <span class=p>(</span><span class=n>boxMax</span><span class=p>.</span><span class=n>xyz</span> <span class=o>-</span> <span class=n>worldPos</span><span class=p>)</span> <span class=o>/</span> <span class=n>nrdir</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>rbmin</span> <span class=o>=</span> <span class=p>(</span><span class=n>boxMin</span><span class=p>.</span><span class=n>xyz</span> <span class=o>-</span> <span class=n>worldPos</span><span class=p>)</span> <span class=o>/</span> <span class=n>nrdir</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>float3</span> <span class=n>rbminmax</span> <span class=o>=</span> <span class=p>(</span><span class=n>nrdir</span> <span class=o>&gt;</span> <span class=mf>0.0f</span><span class=p>)</span> <span class=o>?</span> <span class=n>rbmax</span> <span class=o>:</span> <span class=n>rbmin</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>distanceToHitPoint</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=nb>min</span><span class=p>(</span><span class=n>rbminmax</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>rbminmax</span><span class=p>.</span><span class=n>y</span><span class=p>),</span> <span class=n>rbminmax</span><span class=p>.</span><span class=n>z</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>worldPos</span> <span class=o>-=</span> <span class=n>cubemapCenter</span><span class=p>.</span><span class=n>xyz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>worldRefl</span> <span class=o>=</span> <span class=n>worldPos</span> <span class=o>+</span> <span class=n>nrdir</span> <span class=o>*</span> <span class=n>distanceToHitPoint</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>worldRefl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-HLSL data-lang=HLSL><span class=line><span class=cl><span class=c1>//in object fragment shader...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//calculate a basic fresnel term (cheap)</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>fresnelTerm</span> <span class=o>=</span> <span class=mf>1.0f</span> <span class=o>-</span> <span class=nb>max</span><span class=p>(</span><span class=nb>dot</span><span class=p>(</span><span class=n>vector_normalDirection</span><span class=p>,</span> <span class=n>vector_viewDirection</span><span class=p>),</span> <span class=mf>0.0f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//note: higher power means that you effectively need to be closer to the surface for the contact hardening to appear</span>
</span></span><span class=line><span class=cl><span class=n>fresnelTerm</span> <span class=o>=</span> <span class=nb>pow</span><span class=p>(</span><span class=n>fresnelTerm</span><span class=p>,</span> <span class=n>_ApproximationGodotFresnelPower</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//fresnelTerm = fresnelTerm * fresnelTerm; //hardcoded pow 2.0</span>
</span></span><span class=line><span class=cl><span class=c1>//fresnelTerm = fresnelTerm * fresnelTerm * fresnelTerm; //hardcoded pow 3.0</span>
</span></span><span class=line><span class=cl><span class=c1>//fresnelTerm = fresnelTerm * fresnelTerm * fresnelTerm * fresnelTerm; //hardcoded pow 4.0 (this was the chosen value in the original godot improvement)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//compute reflection vector</span>
</span></span><span class=line><span class=cl><span class=kt>float3</span> <span class=n>vector_reflectionDirection</span> <span class=o>=</span> <span class=nb>reflect</span><span class=p>(</span><span class=o>-</span><span class=n>vector_viewDirection</span><span class=p>,</span> <span class=n>vector_normalDirection</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//remap our smoothness parameter to PBR roughness</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>perceptualRoughness</span> <span class=o>=</span> <span class=mf>1.0</span> <span class=o>-</span> <span class=n>_Smoothness</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>roughness</span> <span class=o>=</span> <span class=n>perceptualRoughness</span> <span class=o>*</span> <span class=n>perceptualRoughness</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//compute the cubemap mip level based on perceptual roughness</span>
</span></span><span class=line><span class=cl><span class=c1>//NOTE: this is basically perceptualRoughness * UNITY_SPECCUBE_LOD_STEPS</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>mipOriginal</span> <span class=o>=</span> <span class=n>UnityPerceptualRoughnessToMipmapLevel</span><span class=p>(</span><span class=n>perceptualRoughness</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//this will store the &#34;intersectionDistance&#34; result from the box projection</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>intersectionDistance</span> <span class=o>=</span> <span class=mo>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//if box projection is enabled, modify our vector to project reflections onto a world space box (defined by the reflection probe)</span>
</span></span><span class=line><span class=cl><span class=n>vector_reflectionDirection</span> <span class=o>=</span> <span class=n>UnityBoxProjectedCubemapDirectionDefault</span><span class=p>(</span><span class=n>vector_reflectionDirection</span><span class=p>,</span> <span class=n>vector_worldPosition</span><span class=p>,</span> <span class=n>unity_SpecCube0_ProbePosition</span><span class=p>,</span> <span class=n>unity_SpecCube0_BoxMin</span><span class=p>,</span> <span class=n>unity_SpecCube0_BoxMax</span><span class=p>,</span> <span class=n>intersectionDistance</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//remap distance to be relative to amount of mips.</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>reflectionRoughness</span> <span class=o>=</span> <span class=n>intersectionDistance</span> <span class=o>/</span> <span class=n>UNITY_SPECCUBE_LOD_STEPS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//reflection roughness shifts depending on the fresnel term</span>
</span></span><span class=line><span class=cl><span class=n>reflectionRoughness</span> <span class=o>*=</span> <span class=mf>1.0</span> <span class=o>-</span> <span class=n>fresnelTerm</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//increase roughness when viewing angle is perpendicular to avoid overly sharp reflections on rough surfaces.</span>
</span></span><span class=line><span class=cl><span class=n>reflectionRoughness</span> <span class=o>+=</span> <span class=p>(</span><span class=mf>1.0</span> <span class=o>-</span> <span class=n>fresnelTerm</span><span class=p>)</span> <span class=o>*</span> <span class=n>perceptualRoughness</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>reflectionRoughness</span> <span class=o>=</span> <span class=nb>saturate</span><span class=p>(</span><span class=n>reflectionRoughness</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//ensures fully rough materials don&#39;t have reflection contact hardening.</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>mipMin</span> <span class=o>=</span> <span class=p>(</span><span class=n>roughness</span> <span class=o>*</span> <span class=n>roughness</span><span class=p>)</span> <span class=o>*</span> <span class=n>UNITY_SPECCUBE_LOD_STEPS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>mip</span> <span class=o>=</span> <span class=nb>lerp</span><span class=p>(</span><span class=n>mipMin</span><span class=p>,</span> <span class=n>mipOriginal</span><span class=p>,</span> <span class=n>reflectionRoughness</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//sample the provided reflection probe at the given mip level</span>
</span></span><span class=line><span class=cl><span class=n>enviormentReflection</span> <span class=o>=</span> <span class=n>UNITY_SAMPLE_TEXCUBE_LOD</span><span class=p>(</span><span class=n>unity_SpecCube0</span><span class=p>,</span> <span class=n>vector_reflectionDirection</span><span class=p>.</span><span class=n>xyz</span><span class=p>,</span> <span class=n>mip</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>enviormentReflection</span><span class=p>.</span><span class=n>rgb</span> <span class=o>=</span> <span class=n>DecodeHDR</span><span class=p>(</span><span class=n>enviormentReflection</span><span class=p>,</span> <span class=n>unity_SpecCube0_HDR</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>This is a recent development I&rsquo;ve been following. As a result of this repository the folks with Godot Engine have been implementing this feature to improve their reflections rendering.</p><ul><li><a class=link href=https://github.com/godotengine/godot-proposals/issues/11670 target=_blank rel=noopener>Godot Proposal 11670</a></li><li><a class=link href=https://github.com/godotengine/godot/pull/106292 target=_blank rel=noopener>Godot Pull 106292</a></li></ul><p>Their implementation is based on my original approximation but a fresnel term has been added as an additional attribute <em>(beyond just surface position/distance)</em> to offset the mip level of the reflection. This has been checked against Blender Cycles renderer for ground-truth comparisons, and <a class=link href=https://github.com/godotengine/godot/pull/106292 target=_blank rel=noopener>accuracy is much improved</a>.</p><p>Apperance wise the effect is more muted and less pronounced, but when at grazing angles the effect starts to become more noticable.</p><p>If we check the Godot approximation against my inital one we can see that the reflections get sharper when we get closer to the surface <em>(thanks to the fresnel term)</em> where with my original approximation it does not.</p><p float=left><img src=3-box-projectedApproxE.png width=49%>
<img src=5-box-projectedGodotC.png width=49%></p><p><em>Left: Approximation | Right: Godot Approximation with Fresnel</em></p><p float=left><img src=3-box-projectedApproxF.png width=49%>
<img src=5-box-projectedGodotD.png width=49%></p><p><em>Left: Approximation + Normal Mapping | Right: Godot Approximation with Fresnel + Normal Mapping</em></p><p>An additional improvement/optimization to this would be utilizing the actual PBR fresnel term that normally gets calculated and multiplied with your environment reflection, rather than just calculating a new fresnel term for this specific instance.</p><p>Once again, a big improvement over the classic method, and it&rsquo;s cheap!</p><h4 id=contact-hardening-raytraced><a href=#contact-hardening-raytraced class=header-anchor></a>Contact Hardening: Raytraced</h4><p><img src=/p/adventures-box-projected-reflections/6-box-projectedRayA.png width=1117 height=662 srcset="/p/adventures-box-projected-reflections/6-box-projectedRayA_hu_11660c32aff4df37.png 480w, /p/adventures-box-projected-reflections/6-box-projectedRayA_hu_8d296f9b4898bb34.png 1024w" loading=lazy alt=6-box-projectedRayA class=gallery-image data-flex-grow=168 data-flex-basis=404px></p><p>Code can be found in here&mldr;</p><ul><li><a class=link href=https://github.com/frostbone25/Unity-Improved-Box-Projected-Reflections/blob/main/ImprovedBoxProjectedReflections/Assets/Shaders/ReflectionTracing.cginc target=_blank rel=noopener>ReflectionTracing.cginc</a></li><li><a class=link href=https://github.com/frostbone25/Unity-Improved-Box-Projected-Reflections/blob/main/ImprovedBoxProjectedReflections/Assets/Shaders/ImprovedBoxProjectedReflections.shader target=_blank rel=noopener>ImprovedBoxProjectedReflections.shader</a></li></ul><p>This is the most accurate method out of the previous ones we had. This is equivalent to ground truth, and unlike the approximations it can properly model anisotropic specular <em>(specular elongation)</em>. It&rsquo;s the most accurate and best looking one. However in comparison it is more complicated and slower than previous methods and requires alot of samples to mitigate artifacts <em><a class=link href=#contact-hardening-raytracing-options>(More on this later)</a></em>.</p><p>It&rsquo;s a massive improvement over the classic method and the approximations, but it&rsquo;s more complicated and expensive <em>(Again more on this later, it&rsquo;s not as bad as you think)</em></p><h3 id=contact-hardening-comparisons-non-normal-mapped-material><a href=#contact-hardening-comparisons-non-normal-mapped-material class=header-anchor></a>Contact Hardening Comparisons (Non-Normal Mapped Material)</h3><p float=left><img src=2-box-projectedA.png width=19%>
<img src=3-box-projectedApproxA.png width=19%>
<img src=4-box-projectedHDRPA.png width=19%>
<img src=5-box-projectedGodotA.png width=19%>
<img src=6-box-projectedRayA.png width=19%></p><p><em>Left To Right: None, Approximation, HDRP Approximation, Godot Approximation, Raytraced</em></p><h3 id=contact-hardening-comparisons-normal-mapped-material><a href=#contact-hardening-comparisons-normal-mapped-material class=header-anchor></a>Contact Hardening Comparisons (Normal Mapped Material)</h3><p float=left><img src=2-box-projectedB.png width=19%>
<img src=3-box-projectedApproxB.png width=19%>
<img src=4-box-projectedHDRPB.png width=19%>
<img src=5-box-projectedGodotB.png width=19%>
<img src=6-box-projectedRayB.png width=19%></p><p><em>Left To Right: None, Approximation, HDRP Approximation, Godot Approximation, Raytraced</em></p><h4 id=contact-hardening-raytracing-options><a href=#contact-hardening-raytracing-options class=header-anchor></a>Contact Hardening: Raytracing Options</h4><p>Earlier we mentioned that while this method is the most accurate and high quality, it&rsquo;s also expensive when compared to it&rsquo;s approximated counterparts. I also want to note that it&rsquo;s important also to keep in mind the &ldquo;raytracing&rdquo; being done here is fairly simple compared to what one might expect, it&rsquo;s just AABB ray testing against the reflection probe bounds. It&rsquo;s all software-based and can even run on a Quest 2 standalone at a decent framerate. With that said there are a few of things we can do here to try to help both improve quality and performance.</p><p>The current implementation also is using an Importance Sampled GGX Function for specular convolution, at 64 samples.</p><p>The blue noise also being used later in the examples/project is a precomputed 3D Texture with 64 slices (64 iterations). The 3D texture being built from 64 slices of precomputed blue noise textures from <a class=link href=https://momentsingraphics.de/BlueNoise.html target=_blank rel=noopener>Moments in Graphics by Christoph Peters</a>. I do also have precomputed <a class=link href=https://developer.nvidia.com/blog/rendering-in-real-time-with-spatiotemporal-blue-noise-textures-part-1/ target=_blank rel=noopener>Spatio-Temporal Blue Noise (STBN)</a> volumes in the project that I also combined, however for some reason the result&rsquo;s I got were worse than with the ones from <a class=link href=https://momentsingraphics.de/BlueNoise.html target=_blank rel=noopener>Christoph Peters</a>. Might be something I did wrong or incorrectly, someone let me know please!</p><h4 id=static-noise-non-deterministic-sampling><a href=#static-noise-non-deterministic-sampling class=header-anchor></a>Static Noise <em>(Non-Deterministic Sampling)</em></h4><p><em>Left: Static White Noise | Right: Static Blue Noise</em></p><p float=left><img src=raytrace-1-whitenoise.png width=49%>
<img src=raytrace-2-bluenoise.png width=49%></p><p>By default white noise is being used. In the current implementation we can use blue-noise sampling to try to improve the perceptual quality. Comparing side by side the difference is small in a static scenario like this, but the blue noise is noticably more consistent and pleasing compared to white noise. At lower sample counts obviously the blue noise shows it&rsquo;s strengths more but of course lower samples = lots of noise regardless.</p><p>One other thing also featured in the shader is a &ldquo;Mip Offset&rdquo; cheat. As it turns out the approximations we have earlier actually work great here and work as a way to blur the results the further the fragment/pixel is. This is something that can be done but in my opinon I would caution against it. Reason being that it alters the reflection properties by blurring the underlying reflection a little too much, and you will start to lose out on that specular enlongation.</p><p><em>Left: Blue Noise | Right: Static Blue Noise With Mip Offsetting</em></p><p float=left><img src=raytrace-2-bluenoise.png width=49%>
<img src=raytrace-3-mip-cheat.png width=49%></p><h4 id=animated-noise-non-deterministic-sampling><a href=#animated-noise-non-deterministic-sampling class=header-anchor></a>Animated Noise <em>(Non-Deterministic Sampling)</em></h4><p><em>Left: Animated White Noise | Right: Animated Blue Noise</em></p><p float=left><img src=raytrace-7-white-noise-animate.png width=49%>
<img src=raytrace-6-blue-noise-animate.png width=49%></p><p>One common solution we can try here is to animate the noise, and accumulate samples over time. This scenario is also where blue noise shines the most, since we are using 1 sample per pixel for every frame, and the sample pattern changes every frame. Using Unity&rsquo;s Default TAA Here and with a stationary camera the results get cleaned up very nicely, and it&rsquo;s performant as it&rsquo;s only 1 sample per pixel, accumlated across multiple frames.</p><p>Now obviously the drawback of this solution is that it is temporal, it accumulates results over multiple frames. Because of that you&rsquo;ll have to deal with the problems that come about with temporal rendering such as disocclusion events, changing perspective, ghosting, and that whole mess. Filtering this with an additional blur that is normal aware will help you here but that introduces inaccuracies as well with trying to retain sharp reflections. Pick your poison.</p><h4 id=deterministic-sampling><a href=#deterministic-sampling class=header-anchor></a>Deterministic Sampling</h4><p>If you don&rsquo;t like noise, you can choose to forgo Monte-Carlo random sampling and instead go for a more uniform/deterministic sampling type. You swap artifacts from noise to aliasing, just like the noise however the more samples you have the better. Better performance in theory <em>(better cache coherence)</em> but can look pretty bad.</p><p><em>Left: Deterministic Sampling | Right: Deterministic Sampling With Mip Offset</em></p><p float=left><img src=raytrace-4-deterministic.png width=49%>
<img src=raytrace-5-mip-cheat.png width=49%></p><p>I also introduced a comparison with the enabled &ldquo;Mip Offsetting&rdquo; approximation which can be used in conjunction with this deterministic sampling approach to get you usable results on smooth surfaces. However just like I mentioned earlier, introducing this does overly blur the reflection and you lose out on that specular elongation.</p><h2 id=beveled-box-projection><a href=#beveled-box-projection class=header-anchor></a>Beveled Box Projection</h2><h4 id=beveled-box-projection-off><a href=#beveled-box-projection-off class=header-anchor></a>Beveled Box Projection: Off</h4><p><img src=/p/adventures-box-projected-reflections/bevel-off.png width=1106 height=650 srcset="/p/adventures-box-projected-reflections/bevel-off_hu_9f4f6d86ac49d473.png 480w, /p/adventures-box-projected-reflections/bevel-off_hu_f3e8da7cd3fcb1bf.png 1024w" loading=lazy alt=bevel-off class=gallery-image data-flex-grow=170 data-flex-basis=408px></p><p>Classic box projection, it&rsquo;s fast and simple, but has sharp edges and can look jarring at grazing angles especially when the cubemap is sampled at a higher mip level.</p><h4 id=beveled-box-projection-on><a href=#beveled-box-projection-on class=header-anchor></a>Beveled Box Projection: On</h4><p><img src=/p/adventures-box-projected-reflections/bevel-on.png width=1106 height=650 srcset="/p/adventures-box-projected-reflections/bevel-on_hu_754a396c381dc9e7.png 480w, /p/adventures-box-projected-reflections/bevel-on_hu_8611f4598b2408d1.png 1024w" loading=lazy alt=bevel-on class=gallery-image data-flex-grow=170 data-flex-basis=408px></p><p>Using a beveled box projection with an adjustable bevel factor, to smooth out the sharp edges you&rsquo;d get with the classic method.</p><p>The initial idea here is</p><ol><li>Give an artist-controlled parameter to smooth out the reflection probe projection.</li><li>A more complex but optically inspired approach by mapping the bevel factor to increased roughness, so the blurrier the reflection gets, the smoother the edges of the box projection are.</li></ol><p>Granted the current implementation has artifacts at high bevel values, note the top left and right sides. You also have to deal with added complexity/instruction counts for a bevel box projection.</p><p><strong>In my opinion</strong>: For most circumstances this is not as transformative as contact hardening, which already visually &ldquo;un-boxes&rdquo; the appearance of your box projected reflection for a much cheaper cost.</p><h2 id=box-based-specular-occlusion><a href=#box-based-specular-occlusion class=header-anchor></a>Box Based Specular Occlusion</h2><p>Another oddball thing we can do, since we have the information of an environment with a box shape. We can use the hit distance from that to do a form of specular occlusion. The closer a pixel/fragment is to the bounds of the box, the more occluded it becomes. So in circumstances where push comes to shove you need to occlude specular or reflections, this is a possible route.</p><h4 id=box-occlusion-off><a href=#box-occlusion-off class=header-anchor></a>Box Occlusion: Off</h4><p><img src=/p/adventures-box-projected-reflections/box-occlusion-off.png width=1106 height=650 srcset="/p/adventures-box-projected-reflections/box-occlusion-off_hu_e02c39637bf129a.png 480w, /p/adventures-box-projected-reflections/box-occlusion-off_hu_216c02d868559f26.png 1024w" loading=lazy alt=box-occlusion-off class=gallery-image data-flex-grow=170 data-flex-basis=408px></p><p>Using the classic box projected reflections, note the glowing apperance where the floor meets the walls.</p><h4 id=box-occlusion-on><a href=#box-occlusion-on class=header-anchor></a>Box Occlusion: On</h4><p><img src=/p/adventures-box-projected-reflections/box-occlusion-on.png width=1106 height=650 srcset="/p/adventures-box-projected-reflections/box-occlusion-on_hu_911c9ae8cd49a58d.png 480w, /p/adventures-box-projected-reflections/box-occlusion-on_hu_d362dd7150636f51.png 1024w" loading=lazy alt=box-occlusion-on class=gallery-image data-flex-grow=170 data-flex-basis=408px></p><p>With box occlusion, there is an added darkening that is introduced. Eliminating the glowing apperance.</p><p><em><strong>NOTE:</strong></em> The material here is a pure metallic/reflective material so the results here can look pretty rough. In cases where you have non-metallic materials this can work well for specular occlusion. It depends on your project/use cases.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-HLSL data-lang=HLSL><span class=line><span class=cl><span class=c1>//recompute reflection direction</span>
</span></span><span class=line><span class=cl><span class=kt>float3</span> <span class=n>vector_specularOcclusionReflectionDirection</span> <span class=o>=</span> <span class=nb>reflect</span><span class=p>(</span><span class=o>-</span><span class=n>vector_viewDirection</span><span class=p>,</span> <span class=n>vector_normalDirection</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//This is the output hit distance, but we will use it as our specular occlusion factor</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>specularOcclusionFactor</span> <span class=o>=</span> <span class=mo>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vector_specularOcclusionReflectionDirection</span> <span class=o>=</span> <span class=n>UnityBoxProjectedCubemapDirectionDefault</span><span class=p>(</span><span class=n>vector_specularOcclusionReflectionDirection</span><span class=p>,</span> <span class=n>vector_worldPosition</span><span class=p>,</span> <span class=n>unity_SpecCube0_ProbePosition</span><span class=p>,</span> <span class=n>unity_SpecCube0_BoxMin</span><span class=p>,</span> <span class=n>unity_SpecCube0_BoxMax</span><span class=p>,</span> <span class=n>specularOcclusionFactor</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//artistic parameters for specular occlusion</span>
</span></span><span class=line><span class=cl><span class=n>specularOcclusionFactor</span> <span class=o>=</span> <span class=nb>pow</span><span class=p>(</span><span class=n>specularOcclusionFactor</span><span class=p>,</span> <span class=n>_ExperimentalSpecularOcclusionPower</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>specularOcclusionFactor</span> <span class=o>*=</span> <span class=n>_ExperimentalSpecularOcclusionMultiplier</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//clamp so we stay within 0..1</span>
</span></span><span class=line><span class=cl><span class=n>specularOcclusionFactor</span> <span class=o>=</span> <span class=nb>saturate</span><span class=p>(</span><span class=n>specularOcclusionFactor</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//apply to environment reflection</span>
</span></span><span class=line><span class=cl><span class=n>enviormentReflection</span> <span class=o>*=</span> <span class=nb>lerp</span><span class=p>(</span><span class=mf>1.0f</span><span class=p>,</span> <span class=n>specularOcclusionFactor</span><span class=p>,</span> <span class=n>_ExperimentalSpecularOcclusionIntensity</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=todoideas><a href=#todoideas class=header-anchor></a>TODO/Ideas:</h3><ul><li>Raytraced: Reflection-Luminance Importance Sampling</li><li>Bevel Box Projection: Fix Artifacts</li></ul><h3 id=credits--sources><a href=#credits--sources class=header-anchor></a>Credits / Sources</h3><ul><li><strong><a class=link href=https://iquilezles.org/articles/intersectors/ target=_blank rel=noopener>Inigo Quilez</a></strong>: Beveled Box Code</li><li><strong><a class=link href=http://momentsingraphics.de/BlueNoise.html target=_blank rel=noopener>Christoph Peters</a></strong>: Free blue noise textures.</li><li><strong><a class=link href=https://github.com/Unity-Technologies/Graphics/blob/504e639c4e07492f74716f36acf7aad0294af16e/Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ target=_blank rel=noopener>Unity HDRP</a></strong>: Approximated Distance Based Roughness Implementation</li><li><strong><a class=link href=https://github.com/Unity-Technologies/Graphics/blob/504e639c4e07492f74716f36acf7aad0294af16e/Packages/com.unity.render-pipelines.core/ShaderLibrary/ target=_blank rel=noopener>Unity SRP Core</a></strong>: Various Functions</li><li><strong><a class=link href=https://github.com/TwoTailsGames/Unity-Built-in-Shaders/blob/master/CGIncludes/ target=_blank rel=noopener>Unity.cginc</a></strong>: Unity Box Projection</li><li><strong><a class=link href=https://www.reddit.com/r/Unity3D/comments/rtmtfz/i_made_a_shader_that_accurately_diffuses_the/ target=_blank rel=noopener>Cactus_On_Fire</a></strong>: Inital inspiration</li><li><strong>George</strong>: Tipping me off to Unity HDRP&rsquo;s implementation</li><li><strong><a class=link href=https://github.com/Calinou target=_blank rel=noopener>Calinou</a></strong>: Improved Godot version of Contact Hardening Approximation.</li><li><strong><a class=link href=https://github.com/lander-vr target=_blank rel=noopener>lander-vr</a></strong>: Improved Godot version of Contact Hardening Approximation.</li><li><strong><a class=link href=https://github.com/clayjohn target=_blank rel=noopener>clayjohn</a></strong>: Improved Godot version of Contact Hardening Approximation.</li></ul><p><em>By: David Matos</em></p></section><footer class=article-footer><section class=article-tags><a href=/tags/unity3d/>Unity3D</a>
<a href=/tags/cubemaps/>Cubemaps</a>
<a href=/tags/reflections/>Reflections</a>
<a href=/tags/specular/>Specular</a></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/adventures-spherical-harmonics-coefficent-precision/><div class=article-image><img src=/p/adventures-spherical-harmonics-coefficent-precision/preview-screenshot.d26ea57200ad79d44ac012ef468bd180_hu_5beb074ca49a9d9.png width=250 height=150 loading=lazy alt="Featured image of post Spherical Harmonics Coefficent Precision" data-key=adventures-spherical-harmonics-coefficent-precision data-hash="md5-0m6lcgCtedRKwBLvRovRgA=="></div><div class=article-details><h2 class=article-title>Spherical Harmonics Coefficent Precision</h2></div></a></article><article class=has-image><a href=/p/adventures-global-illumination-downscaling/><div class=article-image><img src=/p/adventures-global-illumination-downscaling/content/final-rendered-image.512b5aac1a539800f0ed1201d403158b_hu_9aa5ca0eca712a25.png width=250 height=150 loading=lazy alt="Featured image of post Global Illumination Downscaling" data-key=adventures-global-illumination-downscaling data-hash="md5-UStarBpTmADw7RIB1AMViw=="></div><div class=article-details><h2 class=article-title>Global Illumination Downscaling</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=https://github.com/frostbone25/frostbone25.github.io issue-term=pathname label=comment crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2026 David Matos</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.33.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>